# 典型回答

柔性事务，是业内解决分布式事务的主要方案。所谓柔性事务，相比较与数据库事务中的ACID这种刚性事务来说，柔性事务保证的是“基本可用，最终一致。”这其实就是基于BASE理论，保证数据的最终一致性。

虽然柔性事务并不像刚性事务那样完全遵循ACID，但是，也是部分遵循ACID的，简单看一下关于ACID四个属性，柔性事务的支撑程度：

> 原子性：严格遵循
>  
> 一致性：事务完成后的一致性严格遵循；事务中的一致性可适当放宽
>  
> 隔离性：并行事务间不可影响；事务中间结果可见性允许安全放宽
>  
> 持久性：严格遵循


在业内，关于柔性事务**，最主要的有以下三种类型：异步确保型、补偿型、最大努力通知型。**

# 扩展知识

想要实现柔性事务，有几个基础条件需要具备，以下介绍几个柔性事务实现的基础。
## 可查询操作

可查询操作，几乎是所有的分布式解决方案都需要的。

举一个常见的分布式场景的例子，如订单处理这一功能：

 
```
/** 支付订单处理 **/
public void completeOrder() {
    orderDao.update(); // 订单服务本地更新订单状态
    accountService.update(); // 调用资金账户服务给资金帐户加款
    pointService.update(); // 调用积分服务给积分帐户增加积分
    accountingService.insert(); // 调用会计服务向会计系统写入会计原始凭证
    merchantNotifyService.notify(); // 调用商户通知服务向商户发送支付结果通知
}
```
    <br />以上这个支付订单处理的例子中，除了`订单服务本地更新订单状态`以外的所有操作，都需要调用RPC接口来执行，这种情况单纯的本地事务就无法保证数据的一致性了。就需要引入分布式事务。

在分布式事务执行过程中，如果某一个步骤执行出错，就需要明确的知道其他几个操作的处理情况，这就需要其他的服务都能够提供查询接口，保证可以通过查询来判断操作的处理情况。

![](https://cdn.nlark.com/yuque/0/2023/png/5378072/1676785247749-a617e323-d682-4086-a8de-d8a70ef7a7f6.png#averageHue=%23fefbf7&clientId=u6327d0e3-7723-4&from=paste&id=u41dc74a1&originHeight=235&originWidth=436&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=u04c619b5-d53f-4abd-8e7e-a0e0a794e69&title=)

为了保证操作的可查询，需要对于每一个服务的每一次调用都有一个全局唯一的标识，可以是业务单据号（如订单号）、也可以是系统分配的操作流水号（如支付记录流水号）。除此之外，操作的时间信息也要有完整的记录。

## 幂等操作

幂等性，其实是一个数学概念。幂等函数，或幂等方法，是指可以使用相同参数重复执行，并能获得相同结果的函数，如：

    f(f(x)) = f(x)<br />    

在编程中一个幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。也就是说，同一个方法，使用同样的参数，调用多次产生的业务结果与调用一次产生的业务结果相同。

![](https://cdn.nlark.com/yuque/0/2023/png/5378072/1676785273318-04757d3e-a013-456e-adf0-865bd75e2e1b.png#averageHue=%23fefefe&clientId=u6327d0e3-7723-4&from=paste&id=u13eca689&originHeight=271&originWidth=419&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=u03d4aa5f-1ff8-4b20-ab39-ff79c2b9f70&title=)

这一个要求其实也比较好理解，因为要保证数据的最终一致性，很多解决防范都会有很多重试的操作，如果一个方法不保证幂等，那么将无法被重试。

幂等操作的实现方式有多种，如在系统中缓存所有的请求与处理结果、检测到重复操作后，直接返回上一次的处理结果等。

## 可补偿操作

提到事务，为了保证原子性，就可能发生commit和rollback，那么在分布式事务中，要想进行rollback，就需要提供可补偿操作。

![](https://cdn.nlark.com/yuque/0/2023/png/5378072/1676785294019-870c530a-8c74-480e-9d59-517e0d0b29d0.png#averageHue=%23fefefe&clientId=u6327d0e3-7723-4&from=paste&id=u39e718fc&originHeight=241&originWidth=388&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=u5d01da3a-af35-42af-8ea9-b2319ecce40&title=)

比如上面的订单处理的例子中，在`调用积分服务给积分帐户增加积分`操作执行之后，经过分布式事务协调，最终决定回滚整个事务，那么就需要提供一个`调用积分服务给积分帐户扣减积分`的操作。

并且，补偿操作同时也需要满足幂等性。

## TCC操作

TCC 即 Try-Confirm-Cancel。

![](https://cdn.nlark.com/yuque/0/2023/png/5378072/1676785315031-87e9c3e1-c3db-4409-bade-85f42dbc2048.png#averageHue=%23fefbf6&clientId=u6327d0e3-7723-4&from=paste&id=u2555ff47&originHeight=246&originWidth=401&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=uc56f733f-0a40-428b-aa75-758315678fb&title=)

**Try: 尝试执行业务**

完成所有业务检查(一致性) 预留必须业务资源(准隔离性)

**Confirm:确认执行业务**

真正执行业务 不作任何业务检查 只使用Try阶段预留的业务资源 Confirm操作要满足幂等性

**Cancel: 取消执行业务**

释放Try阶段预留的业务资源 ，Cancel操作要满足幂等性

这种类型和可补偿操作类似，就是提供一种提交和回滚的机制。是一种典型的两阶段类型的操作。这里说的两阶段类型操作并不是指2PC，他和2PC还是有区别的。

