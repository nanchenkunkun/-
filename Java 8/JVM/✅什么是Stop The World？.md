
Java中Stop-The-World机制简称STW，是在执行垃圾收集算法时，Java应用程序的其他所有线程都被挂起。这是Java中一种全局暂停现象，全局停顿，所有Java代码停止，native代码可以执行，但不能与JVM交互。

不管选择哪种GC算法，stop-the-world都是不能彻底避免的，只能尽量降低STW的时长。

为什么需要STW呢？

首先，如果不暂停用户线程，就意味着期间会不断有垃圾产生，永远也清理不干净。

其次，用户线程的运行必然会导致对象的引用关系发生改变，这就会导致两种情况：漏标和多标。

多标：其实就是这个对象原本应该被回收掉的垃圾对象，但是被错误的标记成了存活对象。从而导致这个对象没有被GC回收掉。 这种情况还好一点，无非就是产生了一些浮动垃圾，下次GC再清理就好了。

> 垃圾收集在标记的过程中，其实标记的并不是垃圾对象，而是通过可达性分析标记可达对象。所以当一个对象本来是垃圾对象（不可达对象），但是错误的标记成非垃圾对象（可达对象）时，就是**多标**了。就会导致浮动垃圾。


漏标：一个对象本来应该是存活对象，但是没有被正确的标记上，导致被错误的垃圾回收掉了。
