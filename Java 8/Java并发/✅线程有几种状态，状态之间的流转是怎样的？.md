# 典型回答

Java中线程的状态分为6种：<br />1.初始(NEW)：新创建了一个线程对象，但还没有调用start()方法。<br />2.运行(RUNNABLE)：Java线程中将就绪（READY）和运行中（RUNNING）两种状态笼统的称为“运行”。<br />就绪（READY）:线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中并分配cpu使用权 。<br />运行中（RUNNING）：就绪(READY)的线程获得了cpu 时间片，开始执行程序代码。<br />3.阻塞(BLOCKED)：表示线程阻塞于锁（关于锁，在后面章节会介绍）。<br />4.等待(WAITING)：进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）。<br />5.超时等待(TIMED_WAITING)：该状态不同于WAITING，它可以在指定的时间后自行返回。<br />6. 终止(TERMINATED)：表示该线程已经执行完毕。<br />状态流转如图：<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/5378072/1703596501381-ac42214e-f6fa-44ce-a54e-20fc90606afb.png#averageHue=%23f9f9f9&clientId=ud81a7258-fa71-4&from=paste&height=661&id=u22149b49&originHeight=991&originWidth=1454&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=149246&status=done&style=none&taskId=u3409a632-7ec3-4f7f-97da-403b642757c&title=&width=969.3333333333334)

# 拓展知识

## WAITING和TIMED_WAIT的区别？

WAITING是等待状态，在Java中，调用wait方法时，线程会进入到WAITING状态，而TIMED_WAITING是超时等待状态，当线程执行sleep方法时，线程会进入TIMED_WAIT状态。

处于WAITING和TIMED_WAIT的线程，都是会让出CPU的，这时候其他线程就可以获得CPU时间片开始执行。但是他们在对象的锁释放上面并不一样，如果加了锁，sleep方法不会释放对象上的锁，而wait方法是会释放锁的。

 因为Java锁的目标是对象，所以wait、notify和notifyAll针对的目标都是对象，所以把他们定义在Object类中。而sleep不需要释放锁，所以他是Thread类中的一个方法。 
## 为什么线程没有RUNNING状态
对于现在的分时操作系统来说，在单CPU情况下，所有的线程其实都是串行执行的。但是为了让我们看起来像是在并发执行，人们把CPU的执行分成很多个小的时间片。

哪个线程得到时间片，那个线程就执行，时间片到了之后，就要释放出CPU，再重新进行争抢时间片。

只要把时间片划分的足够细，那么多个程序虽然在不断的串行执行，但是看起来也像是在同时执行一样。

![image.png](https://cdn.nlark.com/yuque/0/2022/png/5378072/1665582666549-e9fe6aed-0c0e-4288-8412-4bcc289027f6.png#averageHue=%23deddda&clientId=ud0a794d0-034c-4&from=paste&id=uc23cf36f&originHeight=673&originWidth=1052&originalType=url&ratio=1&rotation=0&showTitle=false&size=394873&status=done&style=none&taskId=u276cdf13-7d21-4e91-9a42-25f8f9dc084&title=)

那么，CPU的时间片其实是很短的，一般也就是10-20毫秒左右。

那么，也就是说，在一秒钟之内，同一个线程可能一部分时间处于READY状态、一部分时间处于RUNNING状态。

那么如果，明确的给线程定义出RUNNING状态的话，有一个很大的问题，就是这个状态其实是不准的。

因为当我们看到线程是RUNNING状态的时候，很有可能他已经丢失了CPU时间片了。

对于线程的状态，我们只需要知道，他当前有没有在"正在参与执行"就行了，何为"参与执行"？

就是他的状态是可执行的，只要获得时间片，就能立即执行。

那这不就是RUNNABLE吗？

所以，Java就没有给线程定义RUNNING状态，而是定义了一个RUNNABLE状态。


