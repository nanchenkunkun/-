## synchronized如何保证原子性

**原子性是指一个操作是不可中断的。**

[✅并发编程中的原子性和数据库ACID的原子性一样吗？](https://www.yuque.com/hollis666/fo22bm/wsfbu382gg5l9ytx?view=doc_embed)

我们知道，线程是CPU调度的基本单位。CPU有时间片的概念，会根据不同的调度算法进行线程调度。当一个线程获得时间片之后开始执行，在时间片耗尽之后，就会失去CPU使用权。所以在多线程场景下，由于时间片在线程间轮换，就会发生原子性问题。

比如线程1获得时间片执行，但是执行过程中，CPU时间片耗尽，他就需要让出CPU，这时线程2获得了时间片开始执行。但是对于线程1来说，他的操作并没有全部执行完成，也没有全都不执行，这就是原子性问题。

那么，synchronized如何保证的原子性呢？

**synchonized其实是通过 monitorenter 和 monitorexit 这两个字节码指令实现的。**

当线程执行到 monitorenter 的时候要先获得锁，才能执行后面的方法。当线程执行到 monitorexit 的时候则要释放锁。

在未释放之前，其他线程是无法再次获得锁的，所以，通过monitorenter和monitorexit指令，可以保证被synchronized修饰的代码在同一时间只能被一个线程访问，在锁未释放之前，无法被其他线程访问到。因此，在Java中可以使用synchronized来保证方法和代码块内的操作是原子性的。

线程1在执行monitorenter指令的时候，会对Monitor进行加锁，加锁后其他线程无法获得锁，除非线程1主动解锁。即使在执行过程中，由于某种原因，比如CPU时间片用完，线程1放弃了CPU，但是，他并没有进行解锁。而由于synchronized的锁是可重入的，下一个时间片还是只能被他自己获取到，还是会继续执行代码。直到所有代码执行完。这就保证了原子性。

[✅什么是时间片](https://www.yuque.com/hollis666/fo22bm/vucgu8?view=doc_embed)

> 这里的时间片是大家一起抢的，并不是因为这个线程加锁了他就一定能抢到，而是因为别的线程抢到没关系，因为别人没有锁，所以这部分代码也无法被执行，最终还是会被持有锁的线程拿到时间片然后继续执行，这也是sync能保证原子性的原因。

## synchronized如何保证有序性

**有序性即程序执行的顺序按照代码的先后顺序执行。**

我们知道，计算机硬件层面做了很多优化，除了引入了时间片以外，由于处理器优化和指令重排等，CPU还可能对输入代码进行乱序执行，比如load->add->save 有可能被优化成load->save->add 。这就是可能存在有序性问题。

那么，想要彻底解决有序性问题，最好的办法就是直接禁止指令重排和处理器优化，但是，synchronized是做不到的，那么为什么我们还说synchronized也提供了有序性保证呢？

这里就需要把有序性的概念扩展一下了，**Java程序中天然的有序性可以总结为一句话：如果在本线程内观察，所有操作都是天然有序的。如果在一个线程中观察另一个线程，所有操作都是无序的。**

以上这句话也是《深入理解Java虚拟机》中的原句，但是怎么理解呢？周志明并没有详细的解释。这里我简单扩展一下，这其实和as-if-serial语义有关。

**as-if-serial语义**的意思指：不管怎么重排序，单线程程序的执行结果都不能被改变。编译器和处理器无论如何优化，都必须遵守as-if-serial语义。

这里不对as-if-serial语义详细展开了，简单说就是，as-if-serial语义保证了单线程中，指令重排是有一定的限制的，而只要编译器和处理器都遵守了这个语义，那么就可以认为单线程程序是按照顺序执行的。当然，实际上还是有重排的，只不过我们无须关心这种重排的干扰。

所以呢，由于synchronized修饰的代码，同一时间只能被同一线程访问。那么也就是单线程执行的。所以，可以保证其有序性。

## synchronized如何保证可见性

**可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。**

Java内存模型规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存，线程的工作内存中保存了该线程中使用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存。

不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量的传递均需要自己的工作内存和主存之间进行数据同步进行。所以，就可能出现线程1改了某个变量的值，但是线程2不可见的情况。

被synchronized修饰的代码，在开始执行时会加锁，执行完成后会进行解锁。而**为了保证可见性，有一条规则是这样的：对一个变量解锁之前，必须先把此变量同步回主存中。这样解锁后，后续线程就可以访问到被修改后的值。**

所以，synchronized关键字锁住的对象，其值是具有可见性的。
