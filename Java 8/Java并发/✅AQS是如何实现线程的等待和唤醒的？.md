# 典型回答

AQS（AbstractQueuedSynchronizer）是Java中实现锁和同步器的基础类，通过FIFO双向队列来管理等待线程和阻塞线程，实现线程之间的协作。

[✅如何理解AQS？](https://www.yuque.com/hollis666/fo22bm/qka9yt?view=doc_embed)

AQS中线程等待和唤醒主要依赖park和unpark实现的。

当一个线程尝试获取锁或者同步器时，如果获取失败，AQS会将该线程封装成一个Node并添加到等待队列中，然后通过LockSupport.park()将该线程阻塞。

当一个线程释放锁或者同步器时，AQS会通过LockSupport.unpark()方法将等待队列中的第一个线程唤醒，并让其重新尝试获取锁或者同步器。

除了基本的等待和唤醒机制，AQS还提供了条件变量（Condition）的实现，用于在某些条件不满足时让线程等待，并在条件满足时唤醒线程。具体实现是通过创建一个等待队列，将等待的线程封装成Node并添加到队列中，然后将这些线程从同步队列中移除，并在条件满足时将等待队列中的所有线程唤醒。

# 扩展知识

## park&unpark

Java中的park()和unpark()方法是一对用于线程等待和唤醒的方法，一般用于实现锁、信号量、线程池等高级并发组件。

park()方法可以使调用线程进入休眠状态，等待被其他线程唤醒，具体实现会让线程进入等待队列中，等待被唤醒。park()方法可以通过传入一个Object类型的参数进行阻塞，这个参数是用来标识这个线程阻塞的原因，方便调试和排查问题。

unpark()方法可以使某个被阻塞的线程被唤醒，让其继续执行。unpark()方法需要传入一个Thread类型的参数，表示要唤醒的线程。


