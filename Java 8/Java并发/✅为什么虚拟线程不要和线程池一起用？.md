# 典型回答

在[JEP425](https://openjdk.org/jeps/425) 中，关于虚拟线程的介绍中，多次提到，不要将虚拟线程池化。也就是说，不要把虚拟线程和线程池合着用。

![1710567916950.png](https://cdn.nlark.com/yuque/0/2024/png/5378072/1710567919428-9f7e8bd4-4ac8-48b6-a227-d09f8eb4b70a.png#averageHue=%23f6f0eb&clientId=uf1fc200d-fb31-4&from=paste&height=301&id=u7ff29370&originHeight=301&originWidth=827&originalType=binary&ratio=1&rotation=0&showTitle=false&size=49240&status=done&style=none&taskId=u0fd619cd-6d41-4be7-946f-53c0d5935a0&title=&width=827)

![image.png](https://cdn.nlark.com/yuque/0/2024/png/5378072/1710567889624-bf0756b8-3d77-4a62-96cb-9af112bfb644.png#averageHue=%23f4f0ed&clientId=uf1fc200d-fb31-4&from=paste&height=412&id=u85622db9&originHeight=412&originWidth=797&originalType=binary&ratio=1&rotation=0&showTitle=false&size=94756&status=done&style=none&taskId=ub7118ec4-7470-4ac3-a088-44727c4d051&title=&width=797)


主要原因是：**像所有资源池一样，线程池旨在共享昂贵的资源，但虚拟线程并不昂贵，因此永远不需要将它们池化。**

**虚拟线程被设计为可以轻松地创建和销毁的轻量级实体**，旨在允许每个任务都在其自己的虚拟线程中运行。这与传统的平台线程不同，后者创建和销毁的成本较高，因此经常被放入线程池中重用以提高效率。

虚拟线程的设计使得它们在遇到阻塞操作（如I/O操作）时可以被挂起，释放底层操作系统线程给其他任务使用。这种模型在高并发场景下能有效利用系统资源，减少了因阻塞操作而浪费的CPU周期。如果虚拟线程被放入池中重用，这种灵活的资源调度优势就会被削弱。

还有就是，虚拟线程的引入有个目的是为了简化并发编程模型，让开发者可以像编写顺序代码一样编写并发代码，而无需担心线程管理和线程池的复杂性。要求虚拟线程不被池化，是为了鼓励开发者利用这一简化的模型，避免回到传统的线程池管理模式。

总之，**我们可以随意利用虚拟线程的轻量级特性和系统资源的高效利用，简化并发编程模型，而无需依赖传统的线程池技术。**
