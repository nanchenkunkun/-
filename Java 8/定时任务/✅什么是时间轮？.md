# 典型回答

时间轮算法（Time Wheel Algorithm）是一种用于处理定时任务和调度的常见算法。

时间轮算法主要需要定义一个时间轮盘，在一个时间轮盘中划分出多个槽位，每个槽位表示一个时间段，这个段可以是秒级、分钟级、小时级等等。如以下就是把一个时间轮分为了60个时间槽，每一个槽代表一秒钟。

![image.png](https://cdn.nlark.com/yuque/0/2023/png/5378072/1697873301595-c5043edb-53b9-4092-839b-dc2f0ddc208f.png#averageHue=%23f8f8f8&clientId=u6b7be485-8a0f-4&from=paste&height=502&id=u30273e80&originHeight=502&originWidth=646&originalType=binary&ratio=1&rotation=0&showTitle=false&size=32662&status=done&style=none&taskId=u129a2604-9fc0-4437-a640-a4f7705b0de&title=&width=646)

然后当我们有定时任务需要执行的时候，就把他们挂在到这些槽位中，这个任务将要在哪个槽位中执行，就把他挂在到哪个槽位的链表上。

比如当前如果是0秒，那么要3秒后执行，那就挂在槽位为3的那个位置上。

![image.png](https://cdn.nlark.com/yuque/0/2023/png/5378072/1697873440333-06e5af62-1795-4891-9f9b-85e3aba1ca72.png#averageHue=%23f9f9f9&clientId=u6b7be485-8a0f-4&from=paste&height=520&id=u6d327fe8&originHeight=520&originWidth=1007&originalType=binary&ratio=1&rotation=0&showTitle=false&size=43364&status=done&style=none&taskId=ueab3896f-88ef-4a29-a19f-6ef3530d3da&title=&width=1007)

而随着时间的推移，轮盘不断旋转，任务会被定期触发。

因为这个时间轮是60个槽位，那么他就会在一分钟完整的转完一圈，那么就有一个指针，每一秒钟在槽位中进行一次移动。这个操作是有一个单独的线程来做的，他的工作就是每一秒钟改变一次current指针。

![image.png](https://cdn.nlark.com/yuque/0/2023/png/5378072/1697873554531-74fc4e6e-b3de-4791-8cae-4caa67ed4ad9.png#averageHue=%23f9f9f9&clientId=u6b7be485-8a0f-4&from=paste&height=520&id=u893b6e4f&originHeight=520&originWidth=1061&originalType=binary&ratio=1&rotation=0&showTitle=false&size=48636&status=done&style=none&taskId=u49b6f4eb-b4fb-41c2-8d17-9313717332a&title=&width=1061)

然后还有一个线程池，在指针轮转到某个槽位上的时候，在线程池中执行链表中需要执行的任务。

以上就是一个简单的时间轮算法，但是这个时间轮存在一个问题，那就是我们把它分了60个槽，那么就意味着我们的定时任务最多只支持60s以内的。

**那么，怎么解决这个问题呢？**

首先能想到的最简单的方式就是加槽位，比如我要支持5分钟的延迟任务，那么就可以把槽位设置为300个。

还有就是也可以调整时间轮槽位移动的延迟，比如把1秒钟移动一次，改为1分钟移动一次，那么就可以支撑60分钟的延迟任务了。

但是这两个办法都不够灵活，而且是有瓶颈的。于是有一种新的办法。

### round

在时间轮中增加一个round的标识，标识运行的圈数，比如说上面的60s的时间轮，如果我要200s之后运行，那么我在设置这个任务的时候，就把他的round设置为 200/60 = 3 ，然后再把它放到 200%60 = 20的这个槽位上。<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/5378072/1697874971503-d956287f-15a0-4338-aa32-cc0b58f80c37.png#averageHue=%23f8f8f8&clientId=u6b7be485-8a0f-4&from=paste&height=523&id=u4183837e&originHeight=523&originWidth=818&originalType=binary&ratio=1&rotation=0&showTitle=false&size=40674&status=done&style=none&taskId=u782f767e-9b7e-4db1-9528-3b7e1ba5177&title=&width=818)

有了这个round之后，每一次current移动到某个槽位时，检查任务的round是不是为0，如果不为0，则减一。

![image.png](https://cdn.nlark.com/yuque/0/2023/png/5378072/1697874978637-e06248d5-af75-4813-8619-fc10da663e57.png#averageHue=%23f9f9f9&clientId=u6b7be485-8a0f-4&from=paste&height=636&id=uf717687e&originHeight=636&originWidth=1561&originalType=binary&ratio=1&rotation=0&showTitle=false&size=86335&status=done&style=none&taskId=u649f2abe-d25c-4fa4-9d27-e2ce612733e&title=&width=1561)

这样时间轮转到第三圈时，round的值会变成0，再第四圈运行到current=20的时候，发现round=0了，那么就可以执行这个任务了。

这样就解决了我们前面说的问题了。

但是这个方案还存在一个问题，那就是这个round的检查过程，需要把所有任务都遍历一遍，效率还是没那么高。

### 分层时间轮

为了解决遍历所有任务的问题，我们可以引入分层时间轮。我们在刚刚的秒级时间轮的基础上，在定义一个分钟级时间轮<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/5378072/1697875385784-e89694fa-ff8d-4780-a6f8-5362db202b00.png#averageHue=%23f7f7f7&clientId=u6b7be485-8a0f-4&from=paste&height=601&id=u7ddcd60d&originHeight=601&originWidth=1259&originalType=binary&ratio=1&rotation=0&showTitle=false&size=75896&status=done&style=none&taskId=ude7aab10-825f-44af-95ca-7c96bd59980&title=&width=1259)

也就是说我们对于200s以后执行这个任务，我们先把他放到分钟级时间轮上，这个时间轮的槽位每一分钟移动一次，当移动时候，发现某个槽位上有这一分钟内需要执行的任务时。

把这个任务取出来，放到秒级时间轮中。这样在第3分20秒的时候，就可以运行这个任务了。

这就是分层时间轮。在分层时间轮包括多个级别的时间轮，每个级别的时间轮都有不同的粒度和周期。

通常，粒度较细的时间轮拥有更短的周期，而粒度较粗的时间轮拥有更长的周期。例如，分层时间轮可以包括毫秒级、秒级、分钟级等不同粒度的时间轮。

当一个任务需要被调度时，它被分配到适当级别的时间轮中，每个级别的时间轮都独立地旋转。当一个时间轮的指针到达某个位置时，它将触发执行该级别时间轮中的任务。如果某个任务在较粗的时间轮中已经到期，它将被升级到下一级时间轮。

当任务升级到下一级时间轮时，任务的调度粒度变得更细。这意味着任务将在更短的时间内被触发，从而更精确地满足其调度要求。


# 扩展知识

## 典型应用

时间轮算法在各种框架和库中都有广泛的应用。以下是一些应用时间轮算法的常见框架和库：

1. Netty：Netty 是一款高性能的网络通信框架，它使用时间轮算法来处理定时任务和超时检测。时间轮用于管理通道的超时和重连机制。
2. Akka：Akka 是一个并发编程框架，它包括一个调度器，该调度器使用时间轮算法来管理和触发并发任务。这使得 Akka 能够支持高并发和复杂的任务调度需求。
3. Kafka：Apache Kafka 是一个分布式消息队列系统，它使用时间轮算法来管理消息的过期和删除。时间轮用于清理过期消息，以释放存储空间。
4. Hystrix：Hystrix 是 Netflix 开发的容错和延迟容忍库，它使用时间轮来管理命令执行和熔断状态的转换。
5. Disruptor：Disruptor 是一个高性能并发框架，它使用时间轮算法来管理任务的并发执行，以提高处理大量事件的性能。
6. xxl-job：在以前的版本的xxl-job中，使用quartz做定时任务调度，但是在7.28版本中去除了quartz，改用了时间轮算法。<br /> 

![image.png](https://cdn.nlark.com/yuque/0/2023/png/5378072/1697875873292-a3511d75-8a26-414b-99e5-5821485f9a59.png#averageHue=%23f5f3f1&clientId=u6b7be485-8a0f-4&from=paste&height=804&id=ufc3721a1&originHeight=804&originWidth=1300&originalType=binary&ratio=1&rotation=0&showTitle=false&size=146937&status=done&style=none&taskId=uf7b73ce7-82f9-4ddd-82e4-476061b8f60&title=&width=1300)
