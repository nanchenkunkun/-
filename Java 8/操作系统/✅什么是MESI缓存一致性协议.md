# 典型回答

[✅什么是操作系统的多级缓存](https://www.yuque.com/hollis666/fo22bm/nm0sde8ek7ccfg1w?view=doc_embed)

由于CPU和主存的处理速度上存在一定差别，为了匹配这种差距，提升计算机能力，人们在CPU和主存之间增加了多层高速缓存。

每个CPU会有L1、L2甚至L3缓存，在多核计算机中会有多个CPU，那么就会存在多套缓存，那么这多套缓存之间的数据就可能出现不一致的现象。为了解决这个问题，有了内存模型。内存模型定义了共享内存系统中多线程程序读写操作行为的规范。通过这些规则来规范对内存的读写操作，从而保证指令执行的正确性。

但是引入了多级缓存之后，就会带来一个缓存一致性的问题。

首先，缓存一致性是由于引入缓存而导致的问题，所以，这是很多CPU厂商必须解决的问题。为了解决前面提到的缓存数据不一致的问题，人们提出过很多方案，通常来说有以下2种方案：<br />1、通过在总线加LOCK#锁的方式。<br />2、通过缓存一致性协议（Cache Coherence Protocol）。

在早期的CPU当中，是通过在总线上加LOCK#锁的形式来解决缓存不一致的问题。因为CPU和其他部件进行通信都是通过总线来进行的，如果对总线加LOCK#锁的话，也就是说阻塞了其他CPU对其他部件访问（如内存），从而使得只能有一个CPU能使用这个变量的内存。在总线上发出了LCOK#锁的信号，那么只有等待这段代码完全执行完毕之后，其他CPU才能从其内存读取变量，然后进行相应的操作。这样就解决了缓存不一致的问题。

但是由于在锁住总线期间，其他CPU无法访问内存，会导致效率低下。因此出现了第二种解决方案，通过缓存一致性协议来解决缓存一致性问题。
### 缓存一致性协议
缓存一致性协议（Cache Coherence Protocol），最出名的就是Intel 的MESI协议，MESI协议保证了每个缓存中使用的共享变量的副本是一致的。

MESI的核心的思想是：当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取。

在MESI协议中，每个缓存可能有有4个状态，它们分别是：

M(Modified)：这行数据有效，数据被修改了，和内存中的数据不一致，数据只存在于本Cache中。<br />E(Exclusive)：这行数据有效，数据和内存中的数据一致，数据只存在于本Cache中。<br />S(Shared)：这行数据有效，数据和内存中的数据一致，数据存在于很多Cache中。<br />I(Invalid)：这行数据无效。

有了这四种状态之后，MESI协议的工作流程如下：

1. 当一个处理器需要读取一个缓存行时，它会首先检查该缓存行的状态。
2. 如果状态是Exclusive或Shared，则直接从缓存中读取数据。因为这两种状态中数据都是有效的。
3. 如果状态是Modified，则表明数据被修改了，则需要先将修改的数据写回主内存，然后再从主内存中读取数据。
4. 如果状态是Invalid，则需要从主内存中加载数据到缓存，并设置状态为Exclusive或Shared。

当一个处理器修改了一个缓存行时，它会将状态设置为Modified，并通知其他处理器或核心该缓存行的状态已被修改，从而导致其他处理器中相应缓存行的状态变为Invalid。

通过这种方式，MESI协议确保了多个缓存中的数据一致性，避免了数据不一致导致的错误。它是一种常见的缓存一致性协议，被广泛应用于多核处理器和多处理器系统中。


# 扩展知识

## MESI和JMM

[✅有了MESI为啥还需要JMM？](https://www.yuque.com/hollis666/fo22bm/yx29gk7wsw26ec4r?view=doc_embed)
