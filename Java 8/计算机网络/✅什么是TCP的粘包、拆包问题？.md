# 典型回答

TCP粘包和拆包问题是指在进行TCP通信时，因为TCP是面向流的，所以发送方在传输数据时可能会将多个小的数据包粘合在一起发送，而接收方则可能将这些数据包拆分成多个小的数据包进行接收，从而导致数据接收出现错误或者数据粘连的问题。

![image.png](https://cdn.nlark.com/yuque/0/2023/png/719664/1673082041585-1f5ab5f1-1bfc-4868-8aef-b36e6681cf5b.png#averageHue=%23f6f5f4&clientId=u1ce059ed-8edd-4&from=paste&height=327&id=TdVx0&originHeight=654&originWidth=1606&originalType=binary&ratio=1&rotation=0&showTitle=false&size=57057&status=done&style=none&taskId=u936b1a6a-6925-46b3-9ddf-aff7804be10&title=&width=803)

TCP粘包和拆包问题主要出现在以下两种情况下：

1. 发送方连续发送多个小数据包：由于TCP是基于流的协议，发送方在传输数据时可能会将多个小数据包组合成一个大数据包进行发送，从而导致接收方在接收数据时无法区分不同数据包之间的界限。
2. 接收方缓存区大小限制：接收方在接收数据时，如果接收缓存区的大小有限，可能会将一个大的数据包拆分成多个小数据包进行接收，从而导致粘包和拆包问题的出现。

## 解决方案
对于粘包和拆包问题，一般都是对包的格式进行约束，常见的解决方案有四种：

- 将业务层协议包的长度固定下来，每个包都**固定长度**，比如512个字节大小，如果客户端发送的数据长度不足512个字节，则通过补充空格的方式补全到指定长度；
- 在每个包的末尾使用**固定的分隔符**，如换行符/n，如果一个包被拆分了，则等待下一个包发送过来之后找到其中的\n，然后对其拆分后的头部部分与前一个包的剩余部分进行合并即可；
- 仿照TCP/IP协议栈，**将消息分为header和body**，在head中保存有当前整个消息的长度，只有在读取到足够长度的消息之后才算是读到了一个完整的消息；
- 通过**自定义协议**进行粘包和拆包的处理。
