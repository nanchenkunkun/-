## 查询优化

#### Explain关键字详解、查询优化远离分析与实战

> 对于一个SQL语句，查询优化器先看是不是能转换成JOIN，再将JOIN进行优化
> 优化分为：1. 条件优化，2.计算全表扫描成本，3. 找出所有能用到的索引，4. 针对每个索引计算不同的访问
> 方式的成本，5. 选出成本最小的索引以及访问方式 

##### 开启查询优化器日志

```
-- 开启
set optimizer_trace="enabled=on";
-- 执行sql
-- 查看日志信息מ
select * from information_schema.OPTIMIZER_TRACE;
-- 关闭
set optimizer_trace="enabled=off";
```

##### 常量传递

```
a=1 and b>a
```



```
上面这个sql可以转换为：

a= 1 and b>1
```



##### 等值传递

```
a=b and b=c and c=5
```

上面这个sql可以装换成

```
a=5 and b=5 and c =5
```

移除没用的条件

```
a=1 and 1=1
```

z转换为

```
a=1
```



##### 基于成本

一个查询可以有不同的执行方案，可以选择某个索引进行查询，也可以选择全表扫描，查询优化器会选择其中成
本最低的方案去执行查询。 



##### I/O 成本

InnoDB存储引擎都是将数据和索引都存储到磁盘上的，当我们想查询表中的记录时，需要先把数据或者索引加载
到内存中然后再操作。这个从磁盘到内存这个加载的过程损耗的时间称之为I/O成本。 



##### CPU成本

读取以及检测记录是否满足对应的搜索条件、对结果集进行排序等这些操作损耗的时间称之为CPU成本。 

> InnoDB存储引擎规定读取一个页面花费的成本默认是1.0，读取以及检测一条记录是否符合搜索条件的成本默认是0.2。 



##### 基于成本的优化步骤

在一条单表查询语句真正执行之前，MySQL的查询优化器会找出执行该语句所有可能使用的方案，对比之后找出
成本最低的方案，这个成本最低的方案就是所谓的执行计划，之后才会调用存储引擎提供的接口真正的执行查
询。
下边我们就以一个实例来分析一下这些步骤，单表查询语句如下： 

```
select * from employees.titles where emp_no > '10101' and emp_no < '20000' and to_date
= '1991-10-10';
```

1.根据搜索条件，找出所有可能使用的索引

emp_no > '10101'，这个搜索条件可以使用主键索引PRIMARY。
to_date = '1991-10-10'，这个搜索条件可以使用二级索引idx_titles_to_date。 

综上所述，上边的查询语句可能用到的索引，也就是possible keys只有PRIMARY和idx_titles_to_date。 

##### 2.计算全表扫描的代价

对于InnoDB存储引擎来说，全表扫描的意思就是把聚簇索引中的记录都依次和给定的搜索条件做一下比较，把符
合搜索条件的记录加入到结果集，所以需要将聚簇索引对应的页面加载到内存中，然后再检测记录是否符合搜索
条件。由于查询成本=I/O成本+CPU成本，所以计算全表扫描的代价需要两个信息：

1. 聚簇索引占用的页面数
2. 该表中的记录数

MySQL为每个表维护了一系列的统计信息， SHOW TABLE STATUS 语句来查看表的统计信息。 

```
show table tatus like 'titles';
```

##### Rows

表示表中的记录条数。对于使用MyISAM存储引擎的来说， 该值是准确的，对于使用InnoDB存储引擎来说，该值是一个估计值。

##### Ddata_length

表示该表占用的存储空间的字节数。使用MyISAM存储引擎的表来说，该值就是数据文件的大小，对于使用InnoDB存储的表来说，该值就相当于聚簇索引占用的存储空间的大小，也就是说可以这样计算该值的大小：

```
Data_length = 聚簇索引页面数量　＊ 每个页面的大小
```

我们的titles使用默认16KB的页面大小，而上边查询结果显示Data_length的值是20512768，所以我们可以反向来
推导出聚簇索引的页面数量： 

```
 聚簇索引页面数量 = Data_length ÷ 16 ÷ 1024 = 20512768 ÷ 16 ÷ 1024 = 1252
```

我们现在已经得到了聚簇索引占用的页面数量以及该表记录数的估计值，所以就可以计算全表扫描成本了。但是
MySQL在真实计算成本时会进行一些微调。
I/O成本：1252*1 = 1252。 1252指的是聚簇索引占用的页面数，1.0指的是加载一个页面的成本常数。
CPU成本：442070*0.2=88414。 442070指的是统计数据中表的记录数，对于InnoDB存储引擎来说是一个估计
值，0.2指的是访问一条记录所需的成本常数
总成本：1252+88414 = 89666。 

综上所述，对于titles的全表扫描所需的总成本就是89666。 

> 我们前边说过表中的记录其实都存储在聚簇索引对应B+树的叶子节点中，所以只要我们通过根节点获得了最
> 左边的叶子节点，就可以沿着叶子节点组成的双向链表把所有记录都查看一遍。也就是说全表扫描这个过程
> 其实有的B+树内节点是不需要访问的，但是MySQL在计算全表扫描成本时直接使用聚簇索引占用的页面数作
> 为计算I/O成本的依据，是不区分内节点和叶子节点的 



##### 3.计算PRIMARY需要成本

计算PRIMARY需要多少成本的关键问题:需要预估出根据对应的where条件在主键索引B+树种存在多少符合条件的记录。

##### 范围区间树

当我们从索引中查询记录时，不管是=、 in、 >、 <这些操作都需要从索引中确定一个范围，不论这个范围区间的
索引到底占用了多少页面，查询优化器粗暴的认为读取索引的一个范围区间的I/O成本和读取一个页面是相同的。
本例中使用PRIMARY的范围区间只有一个：(10101, 20000)，所以相当于访问这个范围区间的索引付出的I/O成本
就是： 

```
1 x 1.0 = 1.0
```

##### 预估范围内的记录数

优化器需要计算索引的某个范围区间到底包含多少条记录，对于本例来说就是要计算PRIMARY在(10101, 20000)
这个范围区间中包含多少条数据记录，计算过程是这样的：
步骤1：先根据emp_no > 10101这个条件访问一下PRIMARY对应的B+树索引，找到满足emp_no

10101这个条件的第一条记录，我们把这条记录称之为区间最左记录。
步骤2：然后再根据emp_no < 20000这个条件继续从PRIMARY对应的B+树索引中找出第一条满足
这个条件的记录，我们把这条记录称之为区间最右记录。
步骤3：如果区间最左记录和区间最右记录相隔不太远（只要相隔不大于10个页面即可），那就可
以精确统计出满足emp_no > '10101' and emp_no < '20000'条件的记录条数。否则只沿着区间最
左记录向右读10个页面，计算平均每个页面中包含多少记录，然后用这个平均值乘以区间最左记
录和区间最右记录之间的页面数量就可以了。那么问题又来了，怎么估计区间最左记录和区间最右
记录之间有多少个页面呢？计算它们父节点中对应的目录项记录之间隔着几条记录就可以了。
根据上面的步骤可以算出来PRIMARY索引的记录条数，所以读取记录的CPU成本为：26808*0.2=5361.6，其中
26808是预估的需要读取的数据记录条数，0.2是读取一条记录成本常数。 

##### PRIMARY的总成本

确定访问的IO成本+过滤数据的CPU成本=1+5361.6=5362.6 

##### 4.计算idx_tiltes_to_date需要成本

因为通过二级索引查询需要回表，所以在计算二级索引需要成本时还要加上回表的成本，而回表的成本就相当于
下面这个SQL执行：

```
select * from employees.titles where 主键字段 in （主键值1，主键值2，。。。。，主键值3）
```

所以idx_titles_to_date的成本 = 辅助索引的查询成本 + 回表查询的成本 

##### 5.比较各成本选出最优者

选在成本最小的索引

##### 基于索引统计数据的成本计算

有时候使用索引执行查询时会有许多单点区间，比如使用IN语句就很容易产生非常多的单点区间，比如下边这个
查询： 

```
select * from employees.titles where to_date in ('a','b','c','d',...,'e');
```

很显然，这个查询可能使用到的索引就是idx_titles_to_date，由于这个索引并不是唯一二级索引，所以并不能确
定一个单点区间对应的二级索引记录的条数有多少，需要我们去计算。计算方式我们上边已经介绍过了，就是先
获取索引对应的B+树的区间最左记录和区间最右记录，然后再计算这两条记录之间有多少记录（记录条数少的时
候可以做到精确计算，多的时候只能估算）。这种通过直接访问索引对应的B+树来计算某个范围区间对应的索引
记录条数的方式称之为index dive。
如果只有几个单点区间的话，使用index dive的方式去计算这些单点区间对应的记录数也不是什么问题，可是如
果很多呢，比如有20000次，MySQL的查询优化器为了计算这些单点区间对应的索引记录条数，要进行20000次
index dive操作，那么这种情况下是很耗性能的，所以MySQL提供了一个系统变量eq_range_index_dive_limit，
我们看一下这个系统变量的默认值： SHOW VARIABLES LIKE '%dive%'; 为200。
也就是说如果我们的IN语句中的参数个数小于200个的话，将使用index dive的方式计算各个单点区间对应的记录
条数，如果大于或等于200个的话，可就不能使用index dive了，要使用所谓的索引统计数据来进行估算。像会为
每个表维护一份统计数据一样，MySQL也会为表中的每一个索引维护一份统计数据，查看某个表中索引的统计数
据可以使用 SHOW INDEX FROM 表名的语法。
Cardinality属性表示索引列中不重复值的个数。比如对于一个一万行记录的表来说，某个索引列的Cardinality属
性是10000，那意味着该列中没有重复的值，如果Cardinality属性是1的话，就意味着该列的值全部是重复的。不
过需要注意的是，对于InnoDB存储引擎来说，使用SHOW INDEX语句展示出来的某个索引列的Cardinality属性是
一个估计值，并不是精确的。可以根据这个属性来估算IN语句中的参数所对应的记录数：
使用SHOW TABLE STATUS展示出的Rows值，也就是一个表中有多少条记录。
使用SHOW INDEX语句展示出的Cardinality属性。
根据上面两个值可以算出idx_key1索引对于的key1列平均单个值的重复次数：Rows/Cardinality
所以总共需要回表的记录数就是：IN语句中的参数个数*Rows/Cardinality 

