1.spring框架的简介

**Spring框架是一个开源的容器性质的轻量级框架。主要有三大特点：容器、IOC（控制反转）、AOP（面向切面编程）。**



2.spring框架的优点

**(1) 容器。Spring框架是一个容器，能够管理项目中的所有对象。**

**(2) IOC（控制反转）。Spring将创建对象的方式反转了，从程序员自己创建反转给了程序。**

**(3) AOP（面向切面）。面向切面编程，简而言之，就是将纵向重复的代码横向抽取出来。Spring框架应用了面向切面的思想，主要体现在为容器中管理的对象生成动态代理对象。**



3.IOC

**IOC：控制反转，指得是将对象的创建权反转给Spring。作用是实现了程序的解耦合。**



4.DI

**DI：依赖注入，需要有IOC环境，在Spring创建Bean对象时，动态的将依赖对象注入到Bean对象中去。依赖注入最大的好处就是解耦合。**



5.BeanFactory 和 ApplicationContext的理解，两者的区别

​	**BeanFactory接口是Spring框架的顶层接口，是最原始的接口，通过new （BeanFactory的实现类）来启动Spring容器时，并不会创建Spring容器里面的对象，只有在每次通过getBean()获得对象时才会创建。**

**ApplicationContext接口是用来替代BeanFactory接口的，通过new （ApplicationContext接口的实现类）ClassPathXmlApplicationContext来启动Spring容器时，就会创建容器中配置的所有对象。**



6.Bean的生命周期

**bean的生命周期包括bean的定义、bean的初始化、bean的调用和bean的销毁。**

**在配置文件里面通过<bean></bean>来完成bean的定义，通过配置init-method属性来完成bean的初始化，通过得到bean的实例对象来完成bean的调用，通过配置destory-method属性来完成bean的销毁。**



7.bean的作用域

**bean有5种作用域，分别是singleton（单例，默认）、prototype、request、session、globalSession。**

**singleton**

**当一个bean的作用域为singleton, 那么Spring IoC容器中只会存在一个共享的bean实例，并且所有对bean的请求，只要id与该bean定义相匹配，则只会返回bean的同一实例。**

**prototype**

**Prototype作用域的bean会导致在每次对该bean请求（将其注入到另一个bean中，或者以程序的方式调用容器的getBean() 方法）时都会创建一个新的bean实例。根据经验，对所有有状态的bean应该使用prototype作用域，而对无状态的bean则应该使用 singleton作用域**

**request**

**在一次HTTP请求中，一个bean定义对应一个实例；即每次HTTP请求将会有各自的bean实例， 它们依据某个bean定义创建而成。该作用 域仅在基于web的Spring ApplicationContext情形下有效。**

**session**

**在一个HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。**

**global session**

**在一个全局的HTTP Session中，一个bean定义对应一个实例。典型情况下，仅在使用portlet context的时候有效。该作用域仅在基于 web的Spring ApplicationContext情形下有效。**



8.springAOP

**Spring可以为所有service层的类生成动态代理对象，告诉spring，为每一个service层的类里面的方法添加管理事务的代码，为所有的service就都加上了管理事务的代码。这样一来，aop思想就体现出来了。SpringAOP的本质就是帮我们生成动态代理对象。**



9.spring是怎么样实现aop的

**JDK动态代理和cglib代理。**

**JDK动态代理有缺陷，就是被代理对象必须实现接口才能产生代理对象，如果没有接口，就不能使用动态代理技术。我们用spring容器来实现动态代理，假如要管理的对象没有实现接口，那么就不能产生代理对象了。为了让所有的对象都能产生动态代理对象，Spring又融入了第三方代理技术cglib代理。Cglib可以对任何类生成代理对象，它的原理是对目标对象进行继承代理，如果目标对象被final修饰，那么该类无法被cglib代理。**



 10.关于aop的一些名词

**Joinpoint（连接点）：目标对象中，所有可以增强的方法**

**Pointcut（切入点）：目标对象，已经增强的方法。**

**Advice（通知/增强）：增强的代码**

**Target（目标对象）：被代理对象**

**Weaving（织入）：将通知应用到切入点的过程**

**Proxy（代理）：将通知织入目标对象之后，形成代理对象**



11.对于aop的理解

​	**AOP，面向切面编程。简单来讲就是将纵向重复的代码，横向抽取出来。**

**很明显的一个体现就是在Filter过滤器中。在没有Filter之前，解决servlet的乱码问题是很复杂的，每次在接收请求之前，都要写句代码来解决乱码问题,即：request.setCharacterEncoding(“UTF-8”)，只要写一个servlet，就是写这句代码来解决乱码问题。直到有一天，Filter出现了。我们把解决乱码的那句代码放到Filter中去，从此在servlet中，就再也不用重复写那句代码了。从架构上来说，Filter解决乱码的事架在了所有的servlet上，这样一来，切面就形成了。**

**面向切面编程的思想，还有一个直接的体现就是在拦截器中。（后面待补充）**



12.springaop的5种类型的通知。

**前置通知（Before）、后置通知（After，在方法完成之后调用通知，无论方法执行是否成功）、后置通知（After-returning，在方法成功执行之后调用通知）、异常通知（After-throwing，在方法抛出异常后调用通知）、环绕通知(Around，在目标方法之前之后都调用)。**



13.springaop的步骤

**（1）导包**

**（2）准备目标对象**

**（3）准备通知**

**（4）将通知织入目标对象中**



14.spring的事务管理

**事务就是对一系列的数据库操作（比如插入多条数据）进行统一的提交或回滚操作，如果插入成功，那么一起成功，如果中间有一条出现异常，那么回滚之前的所有操作。这样可以防止出现脏数据，防止数据库数据出现问题。**

**现实世界中最常见的事务例子可能就是转账了。**



15.事务的4个特性

**原子性（Atomic）：事务是由一个或多个活动所组成的一个工作单元。原子确保事务中的所有操作全部发生或全部不发生。如果所有的活动都成功了，事务也就成功了。如果任意一个活动失败了，整个事务也失败并回滚。**

**一致性（Consistent）：一旦事务完成（不管成功还是失败），系统必须确保它所建模的业务处于一致的状态。现实的数据不应该被损坏。**

**隔离性（Isolated）:事务允许多个用户对相同的数据进行操作，每个用户的操作不会与其他用户纠缠在一起。因此，事务应该被彼此隔离，避免发生同步读写相同数据的事情（注意的是，隔离性往往涉及到锁定数据库中的行或表）。**

**持久性（Durable）:一旦事务完成，事务的结果应该持久化，这样就能从任何的系统崩溃中恢复过来。这一般会涉及将结果存储到数据库或其他形式的持久化存储中。**



16.spring事务的传播行为

**7种。分别是REQUIRED、REQUIRES_NEW、SUPPORTS、NOT_SUPPORTED、MANDATORY、NESTED、NEVER。我们常用的是propagation=”REQUIRED”，默认的就是REQUIRED，指得是支持当前事务，如果不存在，就新建一个（默认），所以这个属性不用配置。其余6个属性几乎不用。**



17.事务中可能出现的问题

**脏读、不可重复读、幻读。**

**解决并发问题的方法就是设置隔离级别。**

 **在理想情况下，事务之间是完全隔离的，从而可以防止这些问题发生，但是完全隔离会导致性能问题，因为它通常会涉及锁定数据库中的记录，侵占性的锁定会阻碍并发性，要求事务互相等待以完成各自的工作。 考虑到完全的隔离会导致性能问题，而且并不是所有的应用程序都需要完全的隔离，所以有时应用程序需要在事务隔离上有一定的灵活性。因此就会有各种隔离级别。**



18.事务中的几种隔离级别

**4种。读未提交（uncommitted）、读已提交（committed）、可重复读（repeatable_read）、串行化（serializable）。**

**读未提交（uncommitted）：允许读取尚未提交的数据变更。可能会导致脏读、幻读或不可重复读。**

**读已提交（committed）:允许读取并发事务已经提交的数据。可以阻止脏读、但是幻读或不可重复读仍有可能发生。**

**可重复读（repeatable_read）：可以阻止脏读和不可重复读，但可能会导致幻读。**

**串行化（serializable）：完全服从ACID的隔离级别，确保阻止脏读、不可重复读以及幻读。这是最慢的事务隔离级别，因为它通常是通过完全锁定事务相关的数据库表来实现的。**



