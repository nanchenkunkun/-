# Zipkin分布式系统调用链追踪

#### zipkin-demo

#### ZIPKIN分布式系统调用链追踪

> 在公司业务发展过程中，刚开始的时候，我们可能比较关注单个请求的调用耗时情况，调用频次统计等一些基本数据指标，因为这个时候业务比较单一，系统相对来说较为简单清晰，调整和优化起来相对来说比较容易一点。

> 但是随着系统业务的不断发展，需求的不断增加，整个系统逐渐变得越来越复杂，有可能还会涉及到外部系统以及公司内部其他系统之间的一个交互。这个时候整个系统的调用链将会变得越来复杂（目前大多数都是分布式调用），更多的时候我们的一个前端请求可能最终需要经过多次后端服务的调用才能得到我们想要的结果数据，而在这个过程中，如果调用超时或者调用变得异常的慢或者调用出现异常等等情况，一般情况下我们是无法准确快速得定位出这次请求出现的问题具体是因为那一部分出现了状况引起的。

> 比如说具体是调用服务A出现了问题，还是服务B不可用亦或者是服务C调用超时等等我们是无法得知的。那这个时候就需要对整个调用链做一次完整的分析才能快速准确的定位出具体的问题，因而分布式调用追踪就诞生了。

## 什么是分布式系统调用追踪？

1. 对多个相互协作的子系统之间的调用关系及依赖关系进行追踪记录
2. 系统与系统之间的调用形式有多种：HTTP、RPC、RMI等等
3. 通过调用链的方式，将一次请求调用过程完整的串联起来，这样就实现了对请求调用路径的监控

## 为什么需要进行分布式调用追踪？

1. 确定服务与服务之间的依赖关系，以便后期优化
2. 统计请求总耗时，以及各个服务的调用耗时，以便解决系统瓶颈
3. 当请求变慢或系统出现异常时，需要尽快确定具体是哪个服务出现问题，以便快速排查线上问题

## 分布式调用追踪需要做什么？

1. 记录从上游到下游关键节点服务的日志信息，入参、出参、异常堆栈等信息
2. 关键节点服务的响应耗时
3. 关键节点服务之间的依赖关系
4. 将分散的请求串联到一起

## 几个关键概念

### traceId：

标识整个请求链，就是一个全局的跟踪ID，是跟踪的入口点，根据需求来决定在哪生成traceId。比如一个http请求，首先入口是web应用，一般看完整的调用链这里自然是traceId生成的起点，结束点在web请求返回点，因此traceId将在这个调用链中进行传递。

### spanId：

标识一次分布式调用，这是下一层的请求跟踪ID,这个也根据自己的需求，比如认为一次rpc，一次sql执行等都可以是一个span。一个traceId包含一个以上的spanId。

### parentId:

上一次请求跟踪ID，用来将前后的请求串联起来。

### cs:

客户端发起请求的时间，比如dubbo调用端开始执行远程调用之前,标志着Span的开始

### cr:

客户端收到处理完请求的时间,标志着Span的结束

### ss:

服务端处理完逻辑的时间

### sr：

服务端收到调用端请求的时间

```
客户端调用时间 = cr-cs
服务端处理时间 = sr-ss 

sr-cs：表示网络延迟和时钟抖动
ss-sr：表示服务端处理请求耗时
cr-ss：表示网络延迟和时钟抖动
```

### ZipKin概述

各个业务系统在相互协作调用时，将特定的跟踪消息传递至zipkin，zipkin在收集到跟踪消息之后将其进行聚合处理，存储，展示等，用户可通过web UI方便清晰获得网络延迟、调用链路、系统依赖等。

### Zipkin主要涉及到四大组件

1. Collector收集器：负责接收各service传输的数据
2. Cassandra存储器：作为Storage的一种，也可以是mysql等，默认存储在内存里面
3. Query查询器：负责查询Storage中存储的数据信息，并且提供简单的JSON API接口获取数据给WEB UI使用
4. Web UI展示器：提供简单的web可视化界面

